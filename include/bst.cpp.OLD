/****************************************************
* bst.cpp
*
* Constructors and Methods sbinlignum Class
*
* Node.js Addons C/C++
*
* Deps: v8, libuv
*
* (C) 2018 Erick Rettozi
*
* MIT LICENCE
****************************************************/

#include <node.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <cstdlib>
#include <sys/time.h>
#include <sys/stat.h>
#include <time.h>
#include <string.h>
#include <algorithm>
#include <exception>
#include <vector>
#include<iostream>
#include "bst.hpp"

using namespace std;
using namespace v8;

using v8::Exception;
using v8::Function;
using v8::FunctionTemplate;
using v8::HandleScope;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;
using v8::Array;

/*
* @Globals
*/
Persistent<Function> BST::constructor;

struct Work {
	uv_work_t  request;
	Persistent<Function> callback;

	std::vector<location> locations;
	std::vector<rain_result> results;
};

struct node {
        int data;
        node *left;
        node *right;
};

node* CreateNode(int data) {
        node *newnode = new node;
        newnode->data = data;
        newnode->left = NULL;
        newnode->right = NULL;

        return newnode;
}

/*
* CONSTRUCTOR()
*
* @Public
*/
BST::BST(Local<Object> objectArgs,Isolate* isolate) {
	// Pego o Array Transports      
        Local<Array> Transports = Local<Array>::Cast(objectArgs->Get(String::NewFromUtf8(isolate,"Transports")));

	/* ------------------------------
	* Confiiguro o(s) Console(s)
	*------------------------------*/

        // Pego o Objeto Console (Local<Array>Transports(Local<Object>Console))
        Local<Value> consoleElem = Local<Value>::Cast(Transports->Get(String::NewFromUtf8(isolate,"Console")));

	// Se for Array de objetos Local<Array>Console<Objeto>
	if(consoleElem->IsArray()) {
		Local<Array> Console = Local<Array>::Cast(consoleElem);
		configureMultipleConsoleTransport(Console,isolate);
	}
	// Se não, configuro somente um console (Local<Object>Console)
	else
	if(consoleElem->IsObject()) {
        	Local<Object> Console = Local<Object>::Cast(Transports->Get(String::NewFromUtf8(isolate,"Console")));
		configureConsoleTransport(Console,isolate);
	}

	/* ------------------------------
	* Confiiguro o(s) Files(s)
	*------------------------------*/

        // Pego o Objeto File (Local<Array>Transports(Local<Object>File))
        Local<Value> fileElem = Local<Value>::Cast(Transports->Get(String::NewFromUtf8(isolate,"File")));

	// Se for Array de objetos Local<Array>File<Objeto>
	if(fileElem->IsArray()) {
		Local<Array> File = Local<Array>::Cast(fileElem);
		configureMultipleFileTransport(File,isolate);
	}
	// Se não, configuro somente um file (Local<Object>File)
	else
	if(fileElem->IsObject()) {
        	Local<Object> File = Local<Object>::Cast(Transports->Get(String::NewFromUtf8(isolate,"File")));
		configureFileTransport(File,isolate);
	}
}

/*
* DESTRUCTOR()
*
* @Public
*/
BST::~BST() {
	//...
}

/*
* Inicializo a lib e seus métodos
*
* @Public
*/
void BST::Init(Local<Object> exports) {
	Isolate* isolate = exports->GetIsolate();

	Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
	tpl->SetClassName(String::NewFromUtf8(isolate, "BST"));
	tpl->InstanceTemplate()->SetInternalFieldCount(2);

	NODE_SET_PROTOTYPE_METHOD(tpl, "search", search);
	NODE_SET_PROTOTYPE_METHOD(tpl, "destroy", destroy);

	constructor.Reset(isolate, tpl->GetFunction());
	exports->Set(String::NewFromUtf8(isolate, "BST"),
        				 tpl->GetFunction());
}

/*
* Método para instanciar a classe
*
* @Public
*/
void BST::New(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();

	if (args.IsConstructCall()) {
		if(args.Length() < 2) {
		    isolate->ThrowException(Exception::TypeError(
		    String::NewFromUtf8(isolate, "Erro: passar pelo menos dois parâmetros")));
		    return;
		}

		//Local<Array> arrayArgs = args[1]->ToArray(isolate);

		//BST* bst = new BST(arrayArgs,isolate);
		//bst->Wrap(args.This());
		//args.GetReturnValue().Set(args.This());
	}
}

/*
* Chamo o destructor da classe
*
* @Public
*/
void Logger::destroy(const FunctionCallbackInfo<Value>& args) {
        Isolate* isolate = args.GetIsolate();
	freeMemory(isolate);
}

/*
* Libero ponteiros da memória
*
* @Private
*/
void Logger::freeMemory(Isolate* isolate) {
	try {
		//...
	} catch (exception& e) {
		isolate->ThrowException(Exception::TypeError(
                        String::NewFromUtf8(isolate, e.what()))
                );
	}
}
